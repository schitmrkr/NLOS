## x86 Assembly

x86 Assembly is a low-level programming language that is used to write code for the x86 architecture. It is a machine language that is used to write code for the x86 architecture.

We will start with the basics and then move on to more advanced topics. We will cover the following topics:

1. x86 Syntax
2. x86 Instructions
3. x86 Registers
4. x86 Memory
5. x86 Stack
6. x86 Flags
7. x86 Interrupts
8. x86 Exceptions
9. x86 System Calls
10. x86 Processors
11. x86 Boot Process
12. x86 Memory Management
13. x86 Process Management
14. x86 Interrupt Management
15. x86 Exception Management
16. x86 System Call Management
17. x86 Processor Management
18. x86 Boot Loader
19. x86 Kernel
20. x86 User Space

---

### x86 Syntax

Assembly syntax defines how an instruction is written. Example(Intel sytax):

```Assembly
mov eax, ebx
```

Meaning: copy value in register ebx to register eax.

x86 has two common syntaxes:

1. Intel Syntax: Used by NASM, MASM, BIOS. Operands destination, source.
2. AT&T Syntax: Used by GCC, GAS. Operands source, destination. (REVERSED)

A general structure of an x86 instruction looks like this:

```Assembly
mnemonic operand1, operand2
```

Example:

```Assembly
add eax, 4
```

You can operate on:

1. Registers: `mov eax, ebx`
2. Immediate values: `mov ecx, 4`
3. Memory: `mov eax, [ebx] ; read memory at address stored in ebx` and `mov [0xB8000], ax ; write ax to VGA memory at address 0xB8000`
4. I/O ports: `in al, dx` and `out dx, al`

On the other hand, labels are used to mark a location in the code. Example:

```Assembly
start:
    mov eax, 0

loop:
    inc eax
    jmp loop
```

A **Label** defines an address the CPU can jump to. Example: `start:` defines an address the CPU can jump to.

Finally, **Directives** are not instructions. They tell assembler how to assemble the code. Example:

`msg db 'A'` defines a byte variable named msg with value 'A'.

`msg dw 0x1234` defines a word variable named msg with value 0x1234.

`msg dd 0x12345678` defines a double word variable named msg with value 0x12345678.

`section .data` defines a data section.

`global _start` defines that \_start is a global symbol. It exports the symbol to the linker.

`extern kmain` imports C function

#### Typical NASM File Structure

```
; Multiboot header
section .multiboot
    dd 0x1BADB002
    dd 0x0
    dd - (0x1BADB002 + 0x0)

; Code
section .text
global _start
extern kmain

_start:
    call kmain

hang:
    jmp hang
```

### x86 Instructions

An instruction tells the CPU exactly what to do for one small step. Examples:

```Assembly
mov eax, 1  ; load a number
add eax, 2. ; add something
jmp loop    ; jump to a label
in al, dx   ; read from hardware port
```

Here are six major groups of instructions:

1. Data Movement: `mov`, `push`, `pop`, `lea`, `xchg`
2. Data Processing: `add`, `sub`, `mul`, `div`, `imul`, `idiv`
3. Control Flow: `jmp`, `call`, `ret`, `int`, `iret`
4. String Operations: `movsb`, `movsw`, `movsd`, `cmpsb`, `cmpsw`, `cmpsd`
5. Bit and Byte Operations: `and`, `or`, `xor`, `not`, `shl`, `shr`, `rol`, `ror`
6. System Operations: `hlt`, `cli`, `sti`, `in`, `out`

Sample Instructions:

```Assembly
; Data Movement Instructions
```

```Assembly
; mov - the king of instrucions

mov eax, ebx      ; copy value in register ebx to register eax

mov eax, 111      ; copy immediate value 111 to register eax

mov al, [0xB8000] ; copy value at memory address 0xB8000 to register al

mov [esp], eax    ; copy value in register eax to memory address stored in esp
```

```Assembly
lea eax, [ebx + 4]  ; load effective address of ebx + 4 into eax

xchg eax, ebx       ; exchange values in eax and ebx

push eax            ; push value in eax to stack

pop ebx             ; pop value from stack to ebx
```

```Assembly
; Arithmentic Instructions
```

```Assembly
add eax, 4
sub ecx, ebx

inc eax    ; increment eax by 1
dec edx    ; decrement edx by 1

mul ebx    ; multiply eax by ebx
imul ebx   ; multiply eax by ebx (signed)

div ebx    ; divide eax by ebx
idiv ebx   ; divide eax by ebx (signed)
```

```Assembly
; Logic/Bitwise Instructions
```

```Assembly
and eax, 0xFF   ; and eax with 0xFF
or eax, 0xFF    ; or eax with 0xFF
xor eax, 0xFF   ; xor eax with 0xFF
not eax         ; not eax

shl eax, 1      ; shift left eax by 1
shr eax, 1      ; shift right eax by 1
rol eax, 1      ; rotate left eax by 1
ror eax, 1      ; rotate right eax by 1
```

```Assembly
; Control Flow Instructions
```

```Assembly
jmp loop    ; jump to a label

call my_function ; call a function
ret          ; return from a function

je label     ; jump if equal
jne label    ; jump if not equal
jg label     ; jump if greater
jl label     ; jump if less
```

```Assembly
; Stack Frame Instructions
```

```Assembly
push ebp     ; push base pointer to stack
mov ebp, esp ; move stack pointer to base pointer

sub esp, 4   ; allocate space for local variables
add esp, 4   ; deallocate space for local variables

mov esp, ebp ; move base pointer to stack pointer
pop ebp      ; pop base pointer from stack

leave        ; mov esp, ebp + pop ebp
ret          ; return from function
```

```Assembly
; Port I/O Instructions
```

```Assembly
in al, dx   ; read byte from port in dx
out dx, al  ; write byte to port in dx
```

```Assembly
; CPU/System Instructions
```

```Assembly
; Used in important kernel critical sections
hlt          ; halt CPU
cli          ; clear interrupts
sti          ; set interrupts
```

```Assembly
iret         ; return from interrupt
cpuid        ; get CPU information
```

### x86 Registers

Registers are very fast storage locations inside the cpu where all arithmentic and logic operations take place.

Here are some categories of x86 registers:

#### General Purpose Registers

In 32-bit mode, there are 8 general purpose registers:

EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP

These are all 32 bit registers. Their subdivision into 16 and 8 bit registers is shown below:

EAX = 32 bits
AX = 16 bits
AH = Upper 8 bits
AL = Lower 8 bits

This is why you see:

```Assembly
in al, dx  ; al is the 8-bit I/O register used for port reading.
```

GPR commonly used for:
EAX - accumulator
EBX - base
ECX - counter
EDX - data
ESI - source index
EDI - destination index
EBP - base pointer
ESP - stack pointer
