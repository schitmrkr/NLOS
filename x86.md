## x86 Assembly

x86 Assembly is a low-level programming language that is used to write code for the x86 architecture. It is a machine language that is used to write code for the x86 architecture.

We will start with the basics and then move on to more advanced topics. We will cover the following topics:

1. x86 Syntax
2. x86 Instructions
3. x86 Registers
4. x86 Memory
5. x86 Stack
6. x86 Flags
7. x86 Interrupts
8. x86 Exceptions
9. x86 System Calls
10. x86 Processors
11. x86 Boot Process
12. x86 Memory Management
13. x86 Process Management
14. x86 Interrupt Management
15. x86 Exception Management
16. x86 System Call Management
17. x86 Processor Management
18. x86 Boot Loader
19. x86 Kernel
20. x86 User Space

---

### x86 Syntax

Assembly syntax defines how an instruction is written. Example(Intel sytax):

```Assembly
mov eax, ebx
```

Meaning: copy value in register ebx to register eax.

x86 has two common syntaxes:

1. Intel Syntax: Used by NASM, MASM, BIOS. Operands destination, source.
2. AT&T Syntax: Used by GCC, GAS. Operands source, destination. (REVERSED)

A general structure of an x86 instruction looks like this:

```Assembly
mnemonic operand1, operand2
```

Example:

```Assembly
add eax, 4
```

You can operate on:

1. Registers: `mov eax, ebx`
2. Immediate values: `mov ecx, 4`
3. Memory: `mov eax, [ebx] ; read memory at address stored in ebx` and `mov [0xB8000], ax ; write ax to VGA memory at address 0xB8000`
4. I/O ports: `in al, dx` and `out dx, al`

On the other hand, labels are used to mark a location in the code. Example:

```Assembly
start:
    mov eax, 0

loop:
    inc eax
    jmp loop
```

A **Label** defines an address the CPU can jump to. Example: `start:` defines an address the CPU can jump to.

Finally, **Directives** are not instructions. They tell assembler how to assemble the code. Example:

`msg db 'A'` defines a byte variable named msg with value 'A'.

`msg dw 0x1234` defines a word variable named msg with value 0x1234.

`msg dd 0x12345678` defines a double word variable named msg with value 0x12345678.

`section .data` defines a data section.

`global _start` defines that \_start is a global symbol. It exports the symbol to the linker.

`extern kmain` imports C function

#### Typical NASM File Structure

```
; Multiboot header
section .multiboot
    dd 0x1BADB002
    dd 0x0
    dd - (0x1BADB002 + 0x0)

; Code
section .text
global _start
extern kmain

_start:
    call kmain

hang:
    jmp hang
```

### x86 Instructions

An instruction tells the CPU exactly what to do for one small step. Examples:

```Assembly
mov eax, 1  ; load a number
add eax, 2. ; add something
jmp loop    ; jump to a label
in al, dx   ; read from hardware port
```

Here are six major groups of instructions:

1. Data Movement: `mov`, `push`, `pop`, `lea`, `xchg`
2. Data Processing: `add`, `sub`, `mul`, `div`, `imul`, `idiv`
3. Control Flow: `jmp`, `call`, `ret`, `int`, `iret`
4. String Operations: `movsb`, `movsw`, `movsd`, `cmpsb`, `cmpsw`, `cmpsd`
5. Bit and Byte Operations: `and`, `or`, `xor`, `not`, `shl`, `shr`, `rol`, `ror`
6. System Operations: `hlt`, `cli`, `sti`, `in`, `out`

Sample Instructions:

```Assembly
; Data Movement Instructions
```

```Assembly
; mov - the king of instrucions

mov eax, ebx      ; copy value in register ebx to register eax

mov eax, 111      ; copy immediate value 111 to register eax

mov al, [0xB8000] ; copy value at memory address 0xB8000 to register al

mov [esp], eax    ; copy value in register eax to memory address stored in esp
```

```Assembly
lea eax, [ebx + 4]  ; load effective address of ebx + 4 into eax

xchg eax, ebx       ; exchange values in eax and ebx

push eax            ; push value in eax to stack

pop ebx             ; pop value from stack to ebx
```

```Assembly
; Arithmentic Instructions
```

```Assembly
add eax, 4
sub ecx, ebx

inc eax    ; increment eax by 1
dec edx    ; decrement edx by 1

mul ebx    ; multiply eax by ebx
imul ebx   ; multiply eax by ebx (signed)

div ebx    ; divide eax by ebx
idiv ebx   ; divide eax by ebx (signed)
```

```Assembly
; Logic/Bitwise Instructions
```

```Assembly
and eax, 0xFF   ; and eax with 0xFF
or eax, 0xFF    ; or eax with 0xFF
xor eax, 0xFF   ; xor eax with 0xFF
not eax         ; not eax

shl eax, 1      ; shift left eax by 1
shr eax, 1      ; shift right eax by 1
rol eax, 1      ; rotate left eax by 1
ror eax, 1      ; rotate right eax by 1
```

```Assembly
; Control Flow Instructions
```

```Assembly
jmp loop    ; jump to a label

call my_function ; call a function
ret          ; return from a function

je label     ; jump if equal
jne label    ; jump if not equal
jg label     ; jump if greater
jl label     ; jump if less
```

```Assembly
; Stack Frame Instructions
```

```Assembly
push ebp     ; push base pointer to stack
mov ebp, esp ; move stack pointer to base pointer

sub esp, 4   ; allocate space for local variables
add esp, 4   ; deallocate space for local variables

mov esp, ebp ; move base pointer to stack pointer
pop ebp      ; pop base pointer from stack

leave        ; mov esp, ebp + pop ebp
ret          ; return from function
```

```Assembly
; Port I/O Instructions
```

```Assembly
in al, dx   ; read byte from port in dx
out dx, al  ; write byte to port in dx
```

```Assembly
; CPU/System Instructions
```

```Assembly
; Used in important kernel critical sections
hlt          ; halt CPU
cli          ; clear interrupts
sti          ; set interrupts
```

```Assembly
iret         ; return from interrupt
cpuid        ; get CPU information
```

### x86 Registers

Registers are very fast storage locations inside the cpu where all arithmentic and logic operations take place.

Here are some categories of x86 registers:

#### General Purpose Registers

In 32-bit mode, there are 8 general purpose registers:

EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP

These are all 32 bit registers. Their subdivision into 16 and 8 bit registers is shown below:

EAX = 32 bits
AX = 16 bits
AH = Upper 8 bits
AL = Lower 8 bits

This is why you see:

```Assembly
in al, dx  ; al is the 8-bit I/O register used for port reading.
```

GPR commonly used for:
EAX - accumulator
EBX - base
ECX - counter
EDX - data
ESI - source index
EDI - destination index
EBP - base pointer
ESP - stack pointer

**EAX Registers**

Used for: return values, arithmetic, port I/O `in al, dx`

```Assembly
mov eax, 10
add eax, 20
in al, dx
```

**EBX Registers**

User for: addressing memory

```Assembly
mov eax, [ebx + 4]
```

**ECX Counter**

Used for: loop instructions

```Assembly
mov ecx, 10
loop_start:
    dec ecx
    jnz loop_start
```

**EDX Data Register**

Used for: port numbers, division, multiplication (extremly important for kernel I/O)

```Assembly
mov dx, 0x60
in al, dx ; read from port 0x60
```

**ESI/EDI Index Registers**

Used for: string operations and memory copying

```Assembly
mov esi, source
mov edi, destination
mov ecx, length
rep movsb ; copy string
```

**ESP Stack Pointer**

Points to top of stack. You don't write into it directly, except in low-level code.

**EBP Base Pointer**

Creates function stack frames.

```Assembly
push ebp
mov ebp, esp
...
mov esp, ebp
pop ebp
ret
```

This is how local variables and arguments work.

**The FLAGS Register(EFLAGS)**

Contains status flags and control flags used by CPU.

```Assembly
ZF - Zero Flag
CF - Carry Flag
PF - Parity Flag
SF - Sign Flag
OF - Overflow Flag
IF - Interrupt Flag
```

```Assembly
cmp eax, ebx
je equal_label ; jumps if ZF = 1
```

**The instruction pointer(EIP)**

Points to instruction currently executing. You cannot modify it directly, only via:

```Assembly
jpm
call
ret
; interrupts
; exceptions
```

### x86 Memory Addressing

Memory addressing is a way to access data stored in memory. Memory access usually looks like:

```Assembly
mov eax, [address]
```

This means go to memory at address, read 4 bytes(32 bits), and put them into eax.

Some basic memory addressing methods:

```Assembly
mov eax, [0x1000] ; absolute address
mov eax, [ebx]    ; register address
mov eax, [ebx + 4] ; offset address
```

Size matters:

```Assembly
mov al, [ebx] ; read 8 bits
mov ax, [ebx] ; read 16 bits
mov eax, [ebx] ; read 32 bits
```

#### Stack Memory Addressing

Stack grows downwards in memory.

```Assembly
push eax
```

is equivalent to:

```Assembly
sub esp, 4
mov [esp], eax
```

#### Addressing in C vs Assembly

Basic Assignments:

```C
int x = y;
```

Assembly:

```Assembly
mov eax, [y];
mov [x], eax;
```

Pointers:

```C
int *p;
int x = *p;
```

Assembly:

```Assembly
mov eax, [p]
mov eax, [eax]
```

VGA memory:

```C
#define VGA_MEMORY 0xB8000
```

Assembly:

```Assembly
mov edi, 0xB8000
mov byte [edi], 'A'
mov byte [edi+1], 0x07
```

### x86 Stack

The stack is a special region in memory used for function calls, local variables, saving registers and returning addresses. On x86, the stack starts at a high address and grows downwards.

#### Stack registers

ESP - Stack Pointer (top of the stack).  
EBP - Base Pointer (frame base)

`push` instruction:

```Assembly
push eax
```

is equivalent to:

```Assembly
sub esp, 4
mov [esp], eax
```

`pop` instruction:

```Assembly
pop eax
```

is equivalent to:

```Assembly
mov eax, [esp]
add esp, 4
```

**Function calls**

`call` and `ret` instructions are used to call and return from functions.

```Assembly
call my_function
```

This pushes return address (EIP) to stack and jumps to my_function.

Equivalent to:

```Assembly
push eip
jmp my_function
```

For `ret`

```Assembly
ret
```

This pops return address from stack and jumps to it.

Equivalent to:

```Assembly
pop eip
```

### x86 Flags

Flags are 1 bit values inside a special register called EFLAGS. They are used to store information about the result of an operation.

#### Core status flags

CF - Carry Flag
ZF - Zero Flag
SF - Sign Flag
PF - Parity Flag
OF - Overflow Flag

Flags control branching:

```Assembly
je label ; ZF = 1
jne label ; ZF = 0
jg label ; signed >
jl label ; signed <
ja label ; unsigned >
jb label ; unsigned <
```

#### Control Flags (Kernel relavant)

IF - Interrupt Flag - Enables interrupt  
DF - Direction Flag - String direction  
TF - Trap Flag - Single step

**Interrupt Flag (IF)**

```Assembly
cli ; clear interrupt flag
sti ; set interrupt flag
```

### x86 Interrupts

An interrupts is a signal that tells CPU: "Stop what you're doing and handle this now."

Without interrupts the CPU would have to constantly check keyboard, check timer, and hardware. This is called polling and is not efficient.

### Types of interrupts

**Hardware interrupts**

Hardware interrupts are generated by external devices such as the keyboard, timer, and hardware. They are also called external interrupts.

**Software interrupts**

Software interrupts are generated by the CPU itself. They are also called internal interrupts (triggered by instructions). Example: `int 0x80`

**Exceptions**

Exceptions are triggered by errors. Example: divide by 0, page fault, invalid instruction, etc.

How interrupts work:

- Finishes current instruction
- Pushes state onto stack
- Switches to kernel mode (if needed)
- Jumps to interrupt handler
- Executes handler
- Restores state
- Continues execution

On x86 (32-bit), CPU pushes

```Assembly
EFLAGS
CS
EIP
```

If privilage level changes (user to kernel), it also pushes

```Assembly
SS
ESP
```

This is called a stack switch.

**Interrupt Vector Table (IVT)/IDT**

CPU needs to know, where the code is for interrupt X. That mapping is stored in Interrupt Descriptor Table(IDT).

Interrupt Numbers:

- 0x00 - Divided by zero
- 0x06 - Invalid opcode
- 0x0E - Page fault
- 0x20 - Timer interrupt
- 0x21 - Keyboard interrupt
- 0x80 - System call (Linux style)

Each IDT entry contains: address of handler, code segment selector, privilage level and type (interrupt gate)

Software interrupt example: `int 0x80`  
CPU pushes state, jumps to interrupt handler at IDT[0x80] and executes it.

Hardware interrupt example (keyboard):  
Key is pressed, keyboard controller signals PIC, PIC signals CPU(IRQ1), CPU triggers interrupt 0x21, keyboard handler runs, keyboard reads scancode from port 0x60.

**Programmable Interrupt Controller (PIC)**

PIC receives IRQs from devices, remaps them, and sends them to CPU.  
Default mapping: IRQ0-7 -> interrputs 0x08-0x0F which confilicts with exception.
So kernel remaps PIC to: IRQ0 -> 0x20, IRQ1 -> 0x21, etc.

Enabling/Disabling interrupts:

```Assembly
cli ; clear interrupt flag
sti ; set interrupt flag
```

### X86 Exceptions

Exceptions are triggered by errors. An exception is a CPU-generated interrupt triggered by CPU itself when an illegal operation occurs, something needs special handling or a program violates a rule.

Unlike hardware interrupts, exceptions are synchronous - they happen at a predictable point in the instruction stream.

Common x86 Exceptions:

- 0x00 - Division by zero
- 0x01 - Single step or break point (debug)
- 0x02 - Non-maskable interrupt
- 0x03 - Breakpoint - int 3 instruction
- 0x04 - Overflow - INTO instruction triggered
- 0x05 - Bound range exceeded
- 0x06 - Invalid opcode
- 0x0D - General protection - privilege violation
- 0x0E - Page fault - invalid memory access
- 0x10 - Floating point error

**How exceptions work?**  
CPU executes instruction, exception occurs, CPU pushes EFLAGS, CS, EIP onto stack, jumps to exception handler at IDT[exception number]. Handler fixes the problem or kills the process. CPU returns iret and resumes execution.

### x86 System Calls

System calls are the final bridge between user programs and the kernel. A system call is the only legal way for user space code to ask the kernel to do something privileged.

Examples:

- print to screen
- read keyboard
- allocate memory
- create process

User code cannot access:

- access hardware ports
- modify page tables
- disable interrupts

Only the kernel can. So the user code says "kernel, please do this for me" and the kernel does it. That request is a system call.

Without syscalls, user code could crash the system, security becomes impossible and there would be no isolation between processes.

On x86 (32-bit classic):

- User program executes a special instruction
- CPU switches to kernel mode
- CPU jumps to a kernel-defined entry point
- Kernel reads syscall number + arguments
- Kernel performs action
- Kernel returns to user mode

**int 0x80 - The Classic Syscall**

This is a software interrupt that transfers control to the kernel. The interrupt number is 0x80.

CPU behavior:

- Pushes EFLAGS, CS, EIP
- Switches to kernel privilege
- Jumps to IDT entry 0x80

**Passing data to the kernel**

Syscalls need: syscall number, arguments, return value.

Linux style convention (32-bit)
EAX - syscall number
EBX - arg1
ECX - arg2
EDX - arg3
Return - EAX

Example user program:

```Assembly
mov eax, 1  ; syscall number
mov ebx, 42 ; argument
int 0x80
```

Kernel receives syscall #1 and argument 42.

**Kernel Side: Syscall Handler**

IDT entry 0x80 points to:

```Assembly
syscall_entry:
    pusha
    call syscall_dispatch
    popa
    iret
```

**Syscall Dispatcher in C**

```C
int syscall_dispatch(int num, int a, int b, int c) {
    switch (num) {
        case 0: return sys_exit(a);
        case 1: return sys_write(a);
        default: return -1;
    }
}
```

**Stack during syscalls**

CPU pushes:

```
EFLAGS
CS
EIP
```

x86 privilege levels:

- 0 - Kernel mode
- 3 - User mode

Syscalls:

- transition Ring 3 â†’ Ring 0
- controlled by CPU
- cannot be faked by user code

**Simple Kernel Syscall Example**

Kernel code:

```C
int sys_putchar(char c) {
    vga_putchar(c);
    return 0;
}
```

User code:

```Assembly
mov eax, 1
mov ebx, 'A'
int 0x80
```

Result: character printed to screen.

**Why iret matters?**

iret restores EIP, CS, EFLAGS. CPU jumps back to user mode, flags are restored to original state and interrupts behave correctly.

| Mistake             | Result          |
| ------------------- | --------------- |
| Forget `iret`       | crash           |
| Wrong IDT privilege | syscall blocked |
| Corrupt stack       | instant reset   |
| No validation       | security hole   |

Syscalls define:

- what user programs can do
- how safe the OS is
- how portable programs are

Everything above syscalls is user space. Everything below is kernel space. Syscalls are also referred to as Kernel API.

### x86 Processes
